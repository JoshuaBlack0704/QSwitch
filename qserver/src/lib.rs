use std::{
    collections::HashMap, mem::size_of, net::SocketAddr, slice::from_raw_parts, sync::Arc,
    time::Duration,
};

use tokio::{net::UdpSocket, runtime::Runtime, sync::{RwLock, RwLockReadGuard}, time::{sleep, Instant}};

//Revision 2
//The cluster terminal is the main interface to a connected terminal.
//The cluster terminal will be responisible for managing connections to other cluster
//terminals. The cluster terminal will mantain connection state and perform keep alive
//operations for udp connection channels. The connection terminal will also be
//the entry point for udp inflow and will route messages to the desired destination,
//likey a CommGroup. The ClusterTerminal, as of now, will also provide automatic
//ACK systems should a message request them.

//The CommGroup represents a logical set of communicaton listeners. Essentially
//the CommGroup will contain an arbitratry number of ports that can connect and
//disconnect at will. These ports serve as logical routing targets for CommGroup
//messages.

//Upon receiving a network packet the ClusterTerminal will look at the packets header.
//Which will be [u32][u32][bool][u32][u32][u8; 500] or [messageID][packetIndex][ACK][CommGroupID][portID][u8; 500].
//The messageID represents a WHOLE message, which may or may not be split into multiple packets.
//The messageID is randomly generated by the sender and if it is not recognized a new
//async task is spawned to handle reassembling a whole message as well as ACK handlling
//if requested. If the messageID is already known and active then the packet is just sent
//to that active message handler. The packetIndex is index of the current packet. ACK indicates
//that the sender would like to initialize an ACK dialog.
//CommGroupID is the local destination CommGroup and portID is the destination port within
//that local CommGroup. The message is delivered to the CommGroup as (u32,Vec<u8>) or (portID,data)
//after the message has been assembled and, if requested, ACK'ed.
//From there the message is passed to the port, if possible, rebuilt into a target data type, and then
//made availble to the end of the port, likley a channel, for a user to intake.

//For an AI CommGroup, there would be a port for every AI. Should AI1 wish to talk to AI2 it would
//grab, if known, the AI2 CommPort (which behaves, to the AI, like a regular channel) and send a particular
//data type on that CommPort. This message would be delivered to the CommGroup. Next the CommGroup would
//look to see if port AI2 is a local port. If it is, instead of converting the data type to bytes
//it will just pass it directly to port AI2's channel, completely avoiding the network layer. If port AI2 is
//on a different cluster node then the CommGroup will transform the message into bytes and
//prepare a network transfer by converting the target port into [u32][u32][u32][bool][Vec<u8>]
//or [dstClusterTerminal][CommGroupID][portID][ACK][data] then pass it to the
//Cluster Terminal which will convert dstClusterTerminal into an addr,
//Turn the vec of bytes into a vec of Packets of the form
//[messageID][packetIndex][ACK][CommGroupID][portID][u8; 500], and then send the packets; handling any
//ACK dialog if requested.

//The main network system of the Cluster. By connecting multiple
//of these together over a network we can build out a distributed
//network cluster that, when combined with CommGroups is opaque to a user.
pub trait Transferable {
    fn to_transfer(&self) -> &[u8];
}
pub struct ClusterTerminal {
    //The main runtime used by all network systems
    rt: Arc<Runtime>,
    //The line of communication with the active network main task
    socket: SocketHandler,
    network_terminate: TerminateSignal,
    //the set of open comm groups
    //NOTE: If a terminal creates a new comgroup it will randomly generate a new ID
    //instead of selecting the next index in case another terminal
    //is simultaneoulsy creating another commgroup. It will then
    //validate that there are no other commgroups using that id, regen+repeat
    //if there is. Then it will start an new commgroup dialog with the
    //other terminals so they also add them to their sets.
}
#[derive(Clone, Debug)]
//This is the base message that all terminals send to each other.
//This is also used for internal Terminal messages such as the shutdown command
pub enum TerminalMessage {
    NewNode,
    NewNodeInfo(SocketAddr),
    KeepAlive,
    Terminate,
    Data(usize,usize,[u8;483]),
}
pub struct CommGroup {}
pub struct CommPort {}
#[derive(Clone)]
pub struct TerminateSignal {
    channel: (flume::Sender<bool>, flume::Receiver<bool>),
}
#[derive(Clone)]
pub struct TerminalAddressMap {
    active_connections: Arc<RwLock<HashMap<SocketAddr, Arc<RwLock<TerminalConnection>>>>>,
}
pub struct TerminalConnection {
    addr: SocketAddr,
    socket: SocketHandler,
    terminal_map: TerminalAddressMap,
    keep_alive_time: Instant,
    life: Arc<TerminateSignal>,
}
#[derive(Clone)]
pub struct SocketHandler {
    socket: Arc<UdpSocket>,
}
type SocketMessage = (usize, [u8; 576], SocketAddr);

impl ClusterTerminal {
    //Starts the network system and returns the ClusterTerminal object.
    //Which is essentially an interface to the running network async tasks.
    pub fn new(socket_addr: SocketAddr) -> Self {
        let rt = Arc::new(Runtime::new().unwrap());
        let socket = SocketHandler::new(socket_addr, rt.clone());
        let root_terminate = TerminateSignal::new();
        rt.spawn(Self::udp_listener(
            socket.clone(),
            root_terminate.subscribe(),
        ));
        println!(
            "Starting new cluster terminal on address {}",
            socket.local_address()
        );
        ClusterTerminal {
            rt,
            socket,
            network_terminate: root_terminate,
        }
    }
    pub fn address(&self) -> SocketAddr {
        self.socket.local_address()
    }
    async fn udp_listener(socket: SocketHandler, terminate: TerminateSignal) {
        //Upon receiving a message
        let conns = TerminalAddressMap::new();
        loop {
            tokio::select! {
                _ = terminate.terminated()=>{println!("Terminating udp listener");break;}
                mesg = socket.receive()=>{
                    tokio::spawn(TerminalConnection::receive(conns.clone(), mesg, socket.clone()));
                }
            }
        }
    }
    pub fn join_cluster(&self, addr: SocketAddr) {
        self.rt.block_on(
            self.socket
                .send(addr, TerminalMessage::NewNode.to_transfer()),
        );
    }
    pub fn comm_group_test(&self, addr: SocketAddr){
        self.rt.block_on(
            self.socket
                .send(addr, TerminalMessage::Data(1, 2, [60;483]).to_transfer()),
        );
        
    }
    pub fn stop(self) {
        drop(self.network_terminate);
    }
}
impl TerminalAddressMap {
    fn new() -> TerminalAddressMap {
        TerminalAddressMap {
            active_connections: Arc::new(RwLock::new(HashMap::new())),
        }
    }
    async fn remove_connection(map: TerminalAddressMap, addr: SocketAddr){
        let mut writer = map.active_connections.write().await;
        writer.remove(&addr);
    }
    async fn get_connection(
        map: TerminalAddressMap,
        addr: SocketAddr,
        socket: SocketHandler,
    ) -> Arc<RwLock<TerminalConnection>> {
        let read = map.active_connections.read().await;
        if let Some(tdata) = read.get(&addr) {
            tdata.clone()
        } else {
            drop(read);
            let mut write = map.active_connections.write().await;
            if let Some(tdata) = write.get(&addr){
                tdata.clone()
            }
            else{
            let tdata = TerminalConnection::new(map.clone(), addr, socket.clone());
            if let Some(_) = write.insert(addr.clone(), tdata.clone()) {
                panic!(
                    "Inserting new terminal connection where there already is one of the same addr"
                );
            };
            tdata
                
            }
        }
    }
    async fn try_get_connection(map: TerminalAddressMap, addr: SocketAddr) -> Option<Arc<RwLock<TerminalConnection>>> {
        let read = map.active_connections.read().await;
        if let Some(tdata) = read.get(&addr){
            Some(tdata.clone())
        }
        else{
            None
        }
            
    }
}
impl TerminalConnection {
    fn new(map: TerminalAddressMap, addr: SocketAddr, socket: SocketHandler) -> Arc<RwLock<TerminalConnection>> {
        println!("Managing new terminal connection from: {}", addr);
        let lt = TerminateSignal::new();
        let terminal = Arc::new(RwLock::new(TerminalConnection {
            addr,
            socket,
            terminal_map: map,
            keep_alive_time: Instant::now(),
            life: Arc::new(lt),
        }));
        tokio::spawn(Self::keep_alive(terminal.clone()));
        terminal
    }
    async fn receive(map: TerminalAddressMap, message: SocketMessage, socket: SocketHandler) {
        let tgt = TerminalAddressMap::get_connection(map,message.2,socket).await;
        let mut writer = tgt.write().await;
        let ptr = &message.1 as *const u8;
        let data = unsafe { from_raw_parts(ptr as *const TerminalMessage, 1)[0].clone() };
        match data {
            TerminalMessage::NewNode => {
                println!("Received new node from {}", writer.addr);
                tokio::spawn(Self::new_node_dialog(tgt.clone()));
            }
            TerminalMessage::KeepAlive => {
                println!("Received keep alive from {}", writer.addr);
                writer.keep_alive_time = Instant::now();
            }
            TerminalMessage::Terminate => todo!(),
            TerminalMessage::Data(comm_group,port,_) => {
                println!("Comm Group Message for {} x {}", comm_group, port);
                
            },
            TerminalMessage::NewNodeInfo(addr) => {
                if addr != writer.socket.local_address() {
                    println!(
                        "Recieved new node dialog message from {} informing of other node {}",
                        writer.addr, addr
                    );
                    tokio::spawn(TerminalAddressMap::get_connection(
                        writer.terminal_map.clone(),
                        addr,
                        writer.socket.clone(),
                    ));
                }
            }
        }
    }
    async fn new_node_dialog(tgt: Arc<RwLock<TerminalConnection>>) {
        let tgt = tgt.read().await;
        let other_terminals = tgt.terminal_map.active_connections.read().await;
        let other_terminals: Vec<Arc<RwLock<TerminalConnection>>> =
            other_terminals.values().map(|t| t.clone()).collect();
        for other in other_terminals.iter() {
            tgt.socket
                .send(
                    tgt.addr,
                    TerminalMessage::NewNodeInfo(other.read().await.addr).to_transfer(),
                )
                .await;
        }
    }
    //This task will provide keep alive functionality as well as send the terminate connection signal
    //Turn all access to a Terminal Connection into an Arc access. If the keep_alive system timesout
    //we pull the terminal connection from the hashmap. Doing so will also end the root lifetime for
    //all of its child tasks.
    async fn keep_alive(tgt: Arc<RwLock<TerminalConnection>>) {
        let reader = tgt.read().await;
        let life = reader.life.subscribe();
        drop(reader);
        //We just need to send a keep alive enum every so often
        loop {
            tokio::select! {
                _ = life.terminated()=>{}
                _ = sleep(Duration::from_millis(1000))=>{
                    let reader = tgt.read().await;
                    reader.socket.send(reader.addr,TerminalMessage::KeepAlive.to_transfer()).await;
                    if Instant::now()-reader.keep_alive_time > Duration::from_millis(10000){
                        TerminalAddressMap::remove_connection(reader.terminal_map.clone(),reader.addr).await;
                        break;
                    }
                }
            }
        }
    }
}
impl Drop for TerminalConnection{
    fn drop(&mut self) {
        println!("Terminating connection to {}", self.addr);
    }
}
impl SocketHandler {
    fn new(socket_addr: SocketAddr, rt: Arc<Runtime>) -> SocketHandler {
        let socket = rt.block_on(UdpSocket::bind(socket_addr)).unwrap();
        SocketHandler {
            socket: Arc::new(socket),
        }
    }
    async fn receive(&self) -> SocketMessage {
        let mut data = [0; 576];
        loop {
            if let Ok((len, addr)) = self.socket.recv_from(&mut data).await {
                return (len, data, addr);
            }
        }
    }
    async fn send(&self, tgt: SocketAddr, data: &[u8]) {
        self.socket.send_to(data, tgt).await.unwrap();
    }
    fn local_address(&self) -> SocketAddr {
        self.socket.local_addr().unwrap()
    }
}
impl Transferable for TerminalMessage {
    fn to_transfer(&self) -> &[u8] {
        let ptr = self as *const Self;
        let data = unsafe { std::slice::from_raw_parts(ptr as *const u8, size_of::<Self>()) };
        data
    }
}
impl TerminateSignal {
    fn new() -> TerminateSignal {
        TerminateSignal {
            channel: flume::bounded(1),
        }
    }
    fn subscribe(&self) -> TerminateSignal {
        let rx = self.channel.1.clone();
        let tx = flume::bounded(1).0;
        TerminateSignal { channel: (tx, rx) }
    }
    async fn terminated(&self) {
        let _ = self.channel.1.recv_async().await;
    }
}
